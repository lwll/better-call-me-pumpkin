<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>flink笔记 | better-call-me-pumpkin</title>
    <meta name="description" content="Recording...">
    <link rel="icon" href="/better-call-me-pumpkin/favicon.ico">
    
    <link rel="preload" href="/better-call-me-pumpkin/assets/css/0.styles.9082b262.css" as="style"><link rel="preload" href="/better-call-me-pumpkin/assets/js/app.99d21adc.js" as="script"><link rel="preload" href="/better-call-me-pumpkin/assets/js/16.c4f0918a.js" as="script"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/10.0382209d.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/11.01c419a7.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/12.96fb6f67.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/13.891cd05f.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/14.e915e9cc.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/15.dc43abf1.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/17.218bd543.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/18.b383d6ff.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/19.1de6cf5c.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/2.45bca6d5.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/20.92e99b9e.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/21.a147a0a8.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/22.05c65fb9.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/23.0e5d1ee0.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/24.f1c352c0.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/3.7ffeac29.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/4.f22338a3.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/5.bb4c53e3.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/6.5b82d692.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/7.f27f30a4.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/8.a10cb67b.js"><link rel="prefetch" href="/better-call-me-pumpkin/assets/js/9.4bc13018.js">
    <link rel="stylesheet" href="/better-call-me-pumpkin/assets/css/0.styles.9082b262.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/better-call-me-pumpkin/" class="home-link router-link-active"><!----> <span class="site-name">better-call-me-pumpkin</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/better-call-me-pumpkin/" class="nav-link">首页</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/tools/" class="nav-link">小工具</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/notes/" class="nav-link">小记</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/blog/" class="nav-link router-link-active">Blog</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/essay/" class="nav-link">随笔</a></div> <a href="https://github.com/lwll/better-call-me-pumpkin" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/better-call-me-pumpkin/" class="nav-link">首页</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/tools/" class="nav-link">小工具</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/notes/" class="nav-link">小记</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/blog/" class="nav-link router-link-active">Blog</a></div><div class="nav-item"><a href="/better-call-me-pumpkin/essay/" class="nav-link">随笔</a></div> <a href="https://github.com/lwll/better-call-me-pumpkin" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Blog</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/better-call-me-pumpkin/blog/HTTP.html" class="sidebar-link">HTTP</a></li><li><a href="/better-call-me-pumpkin/blog/algorithm.html" class="sidebar-link">算法</a></li><li><a href="/better-call-me-pumpkin/blog/CSS Grid布局.html" class="sidebar-link">CSS Grid 网格布局</a></li><li><a href="/better-call-me-pumpkin/blog/egg-lobes.html" class="sidebar-link">egg-lobes</a></li><li><a href="/better-call-me-pumpkin/blog/element-plus.html" class="sidebar-link">element-plus源码分析</a></li><li><a href="/better-call-me-pumpkin/blog/Flink-Table-API-SQL.html" class="sidebar-link">FlinkTable API &amp; SQL</a></li><li><a href="/better-call-me-pumpkin/blog/flink笔记.html" class="active sidebar-link">flink笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#flink架构" class="sidebar-link">Flink架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#jobmanager" class="sidebar-link">JobManager</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#taskmanagers" class="sidebar-link">TaskManagers</a></li></ul></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#flink中的api" class="sidebar-link">Flink中的API</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#有状态流处理" class="sidebar-link">有状态流处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#keyed-state" class="sidebar-link">Keyed State</a></li></ul></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#及时流处理" class="sidebar-link">及时流处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#时间的概念：事件时间和处理时间" class="sidebar-link">时间的概念：事件时间和处理时间</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#事件时间和水印" class="sidebar-link">事件时间和水印</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#并行流中的watermarks" class="sidebar-link">并行流中的watermarks</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#watermarks策略简介" class="sidebar-link">Watermarks策略简介</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#使用watermark策略" class="sidebar-link">使用Watermark策略</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#处理空闲数据源" class="sidebar-link">处理空闲数据源</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#自定义watermarkgenerator" class="sidebar-link">自定义WatermarkGenerator</a></li></ul></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#窗口" class="sidebar-link">窗口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#窗口的生命周期" class="sidebar-link">窗口的生命周期</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#keyed-vs-non-keyed-windows" class="sidebar-link">Keyed vs Non-Keyed Windows</a></li></ul></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#数据管道-etl" class="sidebar-link">数据管道 &amp; ETL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#无状态的转换" class="sidebar-link">无状态的转换</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#keyed-streams" class="sidebar-link">Keyed Streams</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#有状态的转换" class="sidebar-link">有状态的转换</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#connected-streams" class="sidebar-link">Connected Streams</a></li></ul></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#事件驱动应用" class="sidebar-link">事件驱动应用</a></li><li class="sidebar-sub-header"><a href="/better-call-me-pumpkin/blog/flink笔记.html#容错处理" class="sidebar-link">容错处理</a></li></ul></li><li><a href="/better-call-me-pumpkin/blog/Cassandra简述.html" class="sidebar-link">Cassandra简述</a></li><li><a href="/better-call-me-pumpkin/blog/keepalived.html" class="sidebar-link">keepalived</a></li><li><a href="/better-call-me-pumpkin/blog/Nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/better-call-me-pumpkin/blog/RabbitMQ.html" class="sidebar-link">RabbitMQ</a></li><li><a href="/better-call-me-pumpkin/blog/" class="sidebar-link">前言</a></li><li><a href="/better-call-me-pumpkin/blog/redis.html" class="sidebar-link">redis</a></li><li><a href="/better-call-me-pumpkin/blog/TiDB简述.html" class="sidebar-link">TiDB简述</a></li><li><a href="/better-call-me-pumpkin/blog/vue-lobes.html" class="sidebar-link">vue-lobes</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="flink笔记"><a href="#flink笔记" aria-hidden="true" class="header-anchor">#</a> flink笔记</h1> <h2 id="flink架构"><a href="#flink架构" aria-hidden="true" class="header-anchor">#</a> Flink架构</h2> <p>Flink 是一个分布式系统，需要有效分配和管理计算资源才能执行流应用程序。它集成了所有常见的集群资源管理器，例如<a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/YARN.html" target="_blank" rel="noopener noreferrer">Hadoop YARN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://mesos.apache.org/" target="_blank" rel="noopener noreferrer">Apache Mesos<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer">Kubernetes<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，但也可以设置作为独立集群甚至库运行。</p> <p>Flink 运行时由两种类型的进程组成：一个 <em>JobManager</em> 和一个或者多个 <em>TaskManager</em>。</p> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/processes.svg" alt="The processes involved in executing a Flink dataflow"></p> <h3 id="jobmanager"><a href="#jobmanager" aria-hidden="true" class="header-anchor">#</a> JobManager</h3> <p><em>obManager</em> 具有许多与协调 Flink 应用程序的分布式执行有关的职责：它决定何时调度下一个 task（或一组 task）、对完成的 task 或执行失败做出反应、协调 checkpoint、并且协调从失败中恢复等等。这个进程由三个不同的组件组成：</p> <ul><li><p><strong>ResourceManager</strong></p> <p><em>ResourceManager</em> 负责 Flink 集群中的资源提供、回收、分配 - 它管理 <strong>task slots</strong>，这是 Flink 集群中资源调度的单位。Flink 为不同的环境和资源提供者（例如 YARN、Mesos、Kubernetes 和 standalone 部署）实现了对应的 ResourceManager。在 standalone 设置中，ResourceManager 只能分配可用 TaskManager 的 slots，而不能自行启动新的 TaskManager。</p></li> <li><p><strong>Dispatcher</strong></p> <p><em>Dispatcher</em> 提供了一个 REST 接口，用来提交 Flink 应用程序执行，并为每个提交的作业启动一个新的 JobMaster。它还运行 Flink WebUI 用来提供作业执行信息。</p></li> <li><p><strong>JobMaster</strong></p> <p><em>JobMaster</em> 负责管理单个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/concepts/glossary/#logical-graph" target="_blank" rel="noopener noreferrer">JobGraph<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的执行。Flink 集群中可以同时运行多个作业，每个作业都有自己的 JobMaster。</p></li></ul> <h3 id="taskmanagers"><a href="#taskmanagers" aria-hidden="true" class="header-anchor">#</a> TaskManagers</h3> <p><em>TaskManager</em>（也称为 <em>worker</em>）执行作业流的 task，并且缓存和交换数据流。</p> <p>必须始终至少有一个 TaskManager。在 TaskManager 中资源调度的最小单位是 task <em>slot</em>。TaskManager 中 task slot 的数量表示并发处理 task 的数量。请注意一个 task slot 中可以执行多个算子</p> <h2 id="flink中的api"><a href="#flink中的api" aria-hidden="true" class="header-anchor">#</a> Flink中的API</h2> <p>Flink为流式/批式处理应用程序的开发提供了不同级别的抽象</p> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/levels_of_abstraction.svg" alt="Programming levels of abstraction"></p> <h2 id="有状态流处理"><a href="#有状态流处理" aria-hidden="true" class="header-anchor">#</a> 有状态流处理</h2> <p>如果要跨越多个事件（比如多个windows操作）记录信息，这种操作就叫做有状态。</p> <h3 id="keyed-state"><a href="#keyed-state" aria-hidden="true" class="header-anchor">#</a> Keyed State</h3> <h2 id="及时流处理"><a href="#及时流处理" aria-hidden="true" class="header-anchor">#</a> 及时流处理</h2> <p>及时流处理是有状态流处理的扩展。 可以用来处理时间序列分析</p> <h3 id="时间的概念：事件时间和处理时间"><a href="#时间的概念：事件时间和处理时间" aria-hidden="true" class="header-anchor">#</a> 时间的概念：事件时间和处理时间</h3> <ul><li><p>事件时间：</p> <p>事件时间是每个独立的事件在它的生产设备上产生的时间。这个时间一般是时间在进去Flink之前嵌入的。</p></li> <li><p>处理时间</p> <p>处理时间指的是机器进行相应的操作时的系统时间。</p> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/event_processing_time.svg" alt="Event Time and Processing Time"></p></li></ul> <h3 id="事件时间和水印"><a href="#事件时间和水印" aria-hidden="true" class="header-anchor">#</a> 事件时间和水印</h3> <p>Flink中计算程序的event time的原理是watermarks。watermarks作为数据流的一部分，并且带着一个timestamp。<code>Watermark(t)</code>表示数据流中的event time已经到达时间t了，意味着数据流中不应该有timestamp <code>t' &lt;= t</code>的元素。</p> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/stream_watermark_in_order.svg" alt="A data stream with events (in order) and watermarks"></p> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/stream_watermark_out_of_order.svg" alt="A data stream with events (out of order) and watermarks"></p> <h3 id="并行流中的watermarks"><a href="#并行流中的watermarks" aria-hidden="true" class="header-anchor">#</a> 并行流中的watermarks</h3> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/parallel_streams_watermarks.svg" alt="Parallel data streams and operators with events and watermarks"></p> <h3 id="watermarks策略简介"><a href="#watermarks策略简介" aria-hidden="true" class="header-anchor">#</a> Watermarks策略简介</h3> <p>为了使用事件时间语义，Flink应用程序需要知道事件时间戳对应的字段，意味着数据流中的每个元素都需要拥有可分配的事件时间戳。通常通过使用<code>TimestampAssigner</code>API从元素中的某个字段去访问/提取时间戳。</p> <p>时间戳的分配和watermark的生成是齐头并进的，可以告诉Flink应用程序事件时间的进度。可以通过指定<code>WatermarkGenerator</code>来配置<code>watermark</code>的生成方式。</p> <p>使用 Flink API 时需要设置一个同时包含 <code>TimestampAssigner</code> 和 <code>WatermarkGenerator</code> 的 <code>WatermarkStrategy</code>。<code>WatermarkStrategy</code> 工具类中也提供了许多常用的 watermark 策略，并且用户也可以在某些必要场景下构建自己的 watermark 策略。WatermarkStrategy 接口如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">WatermarkStrategy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> 
    <span class="token keyword">extends</span> <span class="token class-name">TimestampAssignerSupplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">WatermarkGetneratorSupplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>

    <span class="token comment">/**
     * 根据策略实例化一个可分配时间戳的 {@link TimestampAssigner}。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">TimestampAssigner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">createTimestampAssigner</span><span class="token punctuation">(</span><span class="token class-name">TimestampAssignerSupplier</span><span class="token punctuation">.</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 根据策略实例化一个 watermark 生成器。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">WatermarkGenerator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">createWatermarkGenerator</span><span class="token punctuation">(</span><span class="token class-name">WatermarkGeneratorSupplier</span><span class="token punctuation">.</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通常情况下，不用实现此接口，而是使用<code>WatermarkStrategy</code>工具类中通用的watermark策略，或者可以使用这个工具类将自定义的<code>TimestampAssigner</code> 与 <code>WatermarkGenerator</code> 进行绑定。例如，你想要要使用有界无序（bounded-out-of-orderness）watermark 生成器和一个 lambda 表达式作为时间戳分配器，那么可以按照如下方式实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">WatermarkStrategy</span>
        <span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Tuple2</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token function">forBoundedOutOfOrderness</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withTimestampAssigner</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> event<span class="token punctuation">.</span>f0<span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><h3 id="使用watermark策略"><a href="#使用watermark策略" aria-hidden="true" class="header-anchor">#</a> 使用Watermark策略</h3> <p><code>WatermarkStrategy</code> 可以在 Flink 应用程序中的两处使用，第一种是直接在数据源上使用，第二种是直接在非数据源的操作之后使用。</p> <p>第一种方式相比会更好，因为数据源可以利用 watermark 生成逻辑中有关分片/分区（shards/partitions/splits）的信息。</p> <h3 id="处理空闲数据源"><a href="#处理空闲数据源" aria-hidden="true" class="header-anchor">#</a> 处理空闲数据源</h3> <p>如果数据源中的某一个分区/分片在一段时间内未发送事件数据，则意味着 <code>WatermarkGenerator</code> 也不会获得任何新数据去生成 watermark。我们称这类数据源为<strong>空闲输入</strong>或<strong>空闲源</strong>。在这种情况下，当某些其他分区仍然发送事件数据的时候就会出现问题。由于下游算子 watermark 的计算方式是取所有不同的上游并行数据源 watermark 的最小值，则其 watermark 将不会发生变化。</p> <p>为了解决这个问题，你可以使用 <code>WatermarkStrategy</code> 来检测空闲输入并将其标记为空闲状态。<code>WatermarkStrategy</code> 为此提供了一个工具接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">WatermarkStrategy</span>
        <span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Tuple2</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token function">forBoundedOutOfOrderness</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withIdleness</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofMinutes</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="自定义watermarkgenerator"><a href="#自定义watermarkgenerator" aria-hidden="true" class="header-anchor">#</a> 自定义WatermarkGenerator</h3> <p>WatermarkGenerator 接口代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * {@code WatermarkGenerator} 可以基于事件或者周期性的生成 watermark。
 *
 * &lt;p&gt;&lt;b&gt;注意：&lt;/b&gt;  WatermarkGenerator 将以前互相独立的 {@code AssignerWithPunctuatedWatermarks} 
 * 和 {@code AssignerWithPeriodicWatermarks} 一同包含了进来。
 */</span>
<span class="token annotation punctuation">@Public</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">WatermarkGenerator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 每来一条事件数据调用一次，可以检查或者记录事件的时间戳，或者也可以基于事件数据本身去生成 watermark。
     */</span>
    <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span><span class="token class-name">T</span> event<span class="token punctuation">,</span> <span class="token keyword">long</span> eventTimestamp<span class="token punctuation">,</span> <span class="token class-name">WatermarkOutput</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 周期性的调用，也许会生成新的 watermark，也许不会。
     *
     * &lt;p&gt;调用此方法生成 watermark 的间隔时间由 {@link ExecutionConfig#getAutoWatermarkInterval()} 决定。
     */</span>
    <span class="token keyword">void</span> <span class="token function">onPeriodicEmit</span><span class="token punctuation">(</span><span class="token class-name">WatermarkOutput</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>watermark 的生成方式本质上是有两种：<em>周期性生成</em>和<em>标记生成</em>。</p> <p>周期性生成器通常通过 <code>onEvent()</code> 观察传入的事件数据，然后在框架调用 <code>onPeriodicEmit()</code> 时发出 watermark。</p> <p>标记生成器将查看 <code>onEvent()</code> 中的事件数据，并等待检查在流中携带 watermark 的特殊标记事件或打点数据。当获取到这些事件数据时，它将立即发出 watermark。通常情况下，标记生成器不会通过 <code>onPeriodicEmit()</code> 发出 watermark。</p> <h2 id="窗口"><a href="#窗口" aria-hidden="true" class="header-anchor">#</a> 窗口</h2> <h3 id="窗口的生命周期"><a href="#窗口的生命周期" aria-hidden="true" class="header-anchor">#</a> 窗口的生命周期</h3> <p>简而言之，只要第一个属于这个窗口的元素到达，窗口就建立了。当时间（事件时间或处理时间）加上用户指定的允许的延迟，超过了它的结束时间戳时，这个窗口就会完全删除。<code>Flink</code>保证只会删除那些基于时间的窗口，其他类型的窗口，比如说全局窗口，不会删除。</p> <h3 id="keyed-vs-non-keyed-windows"><a href="#keyed-vs-non-keyed-windows" aria-hidden="true" class="header-anchor">#</a> Keyed vs Non-Keyed Windows</h3> <p>第一件需要确定的事情，是你的<code>stream</code>是否需要<code>keyed</code>。这个需要在确定<code>window</code>之前就做好。使用<code>keyBy(...)</code>会将你的无限的<code>stream</code>分成有逻辑的<code>keyed streams</code>。如果<code>keyBy(...)</code>没有被调用，你的<code>stream</code>就不会被<code>keyed</code>。</p> <p>对于<code>keyed stream</code>，输入事件的任意属性都可以被用做<code>key</code>。使用一个<code>keyed stream</code>可以让你的窗口计算并行运行在多个任务上，因 为每个逻辑的<code>keyed stream</code>可以独立于其他的stream运行。拥有同一个key的所有元素都会被发送到同一个并行任务。</p> <p>对于<code>non-keyed streams</code>，你的原始的<code>stream</code>不会被拆分成多个逻辑<code>streams</code>，而且所有的窗口逻辑都会在同一个单个任务中执行，即<code>parallelism</code>是1。</p> <p><strong>Keyed Windows</strong></p> <div class="language- extra-class"><pre class="language-text"><code>stream
       .keyBy(...)               &lt;-  keyed versus non-keyed windows
       .window(...)              &lt;-  required: &quot;assigner&quot;
      [.trigger(...)]            &lt;-  optional: &quot;trigger&quot; (else default trigger)
      [.evictor(...)]            &lt;-  optional: &quot;evictor&quot; (else no evictor)
      [.allowedLateness(...)]    &lt;-  optional: &quot;lateness&quot; (else zero)
      [.sideOutputLateData(...)] &lt;-  optional: &quot;output tag&quot; (else no side output for late data)
       .reduce/aggregate/apply()      &lt;-  required: &quot;function&quot;
      [.getSideOutput(...)]      &lt;-  optional: &quot;output tag&quot;
</code></pre></div><p><strong>Non-Keyed Windows</strong></p> <div class="language- extra-class"><pre class="language-text"><code>stream
       .windowAll(...)           &lt;-  required: &quot;assigner&quot;
      [.trigger(...)]            &lt;-  optional: &quot;trigger&quot; (else default trigger)
      [.evictor(...)]            &lt;-  optional: &quot;evictor&quot; (else no evictor)
      [.allowedLateness(...)]    &lt;-  optional: &quot;lateness&quot; (else zero)
      [.sideOutputLateData(...)] &lt;-  optional: &quot;output tag&quot; (else no side output for late data)
       .reduce/aggregate/apply()      &lt;-  required: &quot;function&quot;
      [.getSideOutput(...)]      &lt;-  optional: &quot;output tag&quot;
</code></pre></div><h2 id="数据管道-etl"><a href="#数据管道-etl" aria-hidden="true" class="header-anchor">#</a> 数据管道 &amp; ETL</h2> <h3 id="无状态的转换"><a href="#无状态的转换" aria-hidden="true" class="header-anchor">#</a> 无状态的转换</h3> <h4 id="map"><a href="#map" aria-hidden="true" class="header-anchor">#</a> map()</h4> <p><code>Apache FLink</code>的一种常见应用场景是<code>ETL</code>（抽取、转换、加载）管道任务。从一个或多个数据源获取数据，进行一些转换操作和信息补充，将结果存储起来。</p> <p>官方示例代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">DataStream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TaxiRide</span><span class="token punctuation">&gt;</span></span> rides <span class="token operator">=</span> env<span class="token punctuation">.</span><span class="token function">addSource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TaxiRideSource</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">DataStream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EnrichedRide</span><span class="token punctuation">&gt;</span></span> enrichedNYCRides <span class="token operator">=</span> rides
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RideCleansingSolution</span><span class="token punctuation">.</span><span class="token class-name">NYCFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Enrichment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Enrichment</span> <span class="token keyword">implements</span> <span class="token class-name">MapFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TaxiRide</span><span class="token punctuation">,</span> <span class="token class-name">EnrichedRide</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">EnrichedRide</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">TaxiRide</span> taxiRide<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EnrichedRide</span><span class="token punctuation">(</span>taxiRide<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="flatmap"><a href="#flatmap" aria-hidden="true" class="header-anchor">#</a> flatmap()</h4> <p><code>MapFunction</code>只适用于一对一的转换：对每个进入算子的流元素，<code>map()</code>将仅输出一个转换后的元素。对于除此之外的场景，需要使用<code>flatmap()</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">DataStream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TaxiRide</span><span class="token punctuation">&gt;</span></span> rides <span class="token operator">=</span> env<span class="token punctuation">.</span><span class="token function">addSource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TaxiRideSource</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">DataStream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EnrichedRide</span><span class="token punctuation">&gt;</span></span> enrichedNYCRides <span class="token operator">=</span> rides
    <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NYCEnrichment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

enrichedNYCRides<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其中用到的<code>FlatMapFunction</code>:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">NYCEnrichment</span> <span class="token keyword">implements</span> <span class="token class-name">FlatMapFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TaxiRide</span><span class="token punctuation">,</span> <span class="token class-name">EnrichedRide</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">TaxiRide</span> taxiRide<span class="token punctuation">,</span> <span class="token class-name">Collector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EnrichedRide</span><span class="token punctuation">&gt;</span></span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">FilterFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TaxiRide</span><span class="token punctuation">&gt;</span></span> valid <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RideCleansing</span><span class="token punctuation">.</span><span class="token class-name">NYCFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>taxiRide<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            out<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EnrichedRide</span><span class="token punctuation">(</span>taxiRide<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用接口中提供的 <code>Collector</code> ，<code>flatmap()</code> 可以输出你想要的任意数量的元素，也可以一个都不发。</p> <h3 id="keyed-streams"><a href="#keyed-streams" aria-hidden="true" class="header-anchor">#</a> Keyed Streams</h3> <h4 id="keyby"><a href="#keyby" aria-hidden="true" class="header-anchor">#</a> keyBy()</h4> <p><code>keyBy</code>将一个流根据其中的一些属性来进行分区，从而使所有具有相同属性的事件分到相同的组里。</p> <div class="language-java extra-class"><pre class="language-java"><code>rides
    <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NYCEnrichment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">keyBy</span><span class="token punctuation">(</span>enrichedRide <span class="token operator">-&gt;</span> enrichedRide<span class="token punctuation">.</span>startCell<span class="token punctuation">)</span>
</code></pre></div><p>每个 <code>keyBy</code> 会通过 shuffle 来为数据流进行重新分区。总体来说这个开销是很大的，它涉及网络通信、序列化和反序列化。</p> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/keyBy.png" alt="keyBy and network shuffle"></p> <p>KeySelector 不仅限于从事件中抽取键。也可以按想要的方式计算得到键值:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">keyBy</span><span class="token punctuation">(</span>ride <span class="token operator">-&gt;</span> <span class="token class-name">GeoUtils</span><span class="token punctuation">.</span><span class="token function">mapToGridCell</span><span class="token punctuation">(</span>ride<span class="token punctuation">.</span>startLon<span class="token punctuation">,</span> ride<span class="token punctuation">.</span>startLat<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="keyed-stream的聚合"><a href="#keyed-stream的聚合" aria-hidden="true" class="header-anchor">#</a> Keyed Stream的聚合</h4> <h4 id="reduce-和其他聚合算子"><a href="#reduce-和其他聚合算子" aria-hidden="true" class="header-anchor">#</a> reduce()和其他聚合算子</h4> <h3 id="有状态的转换"><a href="#有状态的转换" aria-hidden="true" class="header-anchor">#</a> 有状态的转换</h3> <p>在flink不参与管理状态的情况下，你的应用也可以使用状态，但Flink为其管理状态提供了一些引人注目的特性：</p> <ul><li>本地性</li> <li>持久性</li> <li>纵向可扩展性</li> <li>横向可扩展性</li> <li>可查询性</li></ul> <h4 id="rich-functions"><a href="#rich-functions" aria-hidden="true" class="header-anchor">#</a> Rich Functions</h4> <p><code>Flink</code>的几种函数接口，包括<code>FilterFunction、MapFunction、FlatMapFunction</code>,都是单一抽象方法模式。<code>Flink</code>同样也为他们提供了一个所谓<code>rich</code>的变体，如<code>RichFlatMapFunction</code>,其中增加了以下放大，包括：</p> <ul><li><code>open(Configuration)</code></li> <li><code>close()</code></li> <li><code>getRuntimeContext()</code></li></ul> <p><code>open()</code>仅在算子初始化时调用一次。可以用来加载一些静态数据，或者建立外部服务的链接等。</p> <p><code>getRuntimeContext()</code>是创建和访问<code>Flink</code>状态的途径</p> <h4 id="一个使用keyed-state的例子"><a href="#一个使用keyed-state的例子" aria-hidden="true" class="header-anchor">#</a> 一个使用Keyed State的例子</h4> <p>在这个例子里，想象有一个要去重的事件数据流，对每个键只保留第一个事件。下面是完成这个功能的应用，使用一个名为<code>Deduplicator</code>的<code>RichFlatMapFunction</code>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> key<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timestamp<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">StreamExecutionEnvironment</span> env <span class="token operator">=</span> <span class="token class-name">StreamExecutionEnvironment</span><span class="token punctuation">.</span><span class="token function">getExecutionEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    env<span class="token punctuation">.</span><span class="token function">addSource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EventSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">keyBy</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Deduplicator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    env<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Deduplicator</code>需要记录每个键是否已经有了相应的记录。它将通过使用Flink的<code>keyed state</code>接口来做这件事，<code>Flink</code>会为每个状态中管理的条目维护一个键值存储。<code>Flink</code>支持几种不同方式的<code>keyed state</code>,这个例子使用的是最简单的一个，叫做<code>ValaueState</code>。意思是对于每个键，<code>FLink</code>将存储一个单一的对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Deduplicator</span> <span class="token keyword">extends</span> <span class="token class-name">RichFlatMapFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Event</span><span class="token punctuation">,</span> <span class="token class-name">Event</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">ValueState</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> keyHasBeenSeen<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token keyword">open</span><span class="token punctuation">(</span><span class="token class-name">Configuration</span> conf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ValueStateDescriptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> desc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ValueStateDescriptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;keyHasBeenSeen&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Types</span><span class="token punctuation">.</span>BOOLEAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        keyHasBeenSeen <span class="token operator">=</span> <span class="token function">getRuntimeContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Event</span> event<span class="token punctuation">,</span> <span class="token class-name">Collector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Event</span><span class="token punctuation">&gt;</span></span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyHasBeenSeen<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            out<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
            keyHasBeenSeen<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>部署在分布式集群时，将会有很多 <code>Deduplicator</code> 的实例，每一个实例将负责整个键空间的互斥子集中的一个。所以，当你看到一个单独的 <code>ValueState</code>，比如</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ValueState</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> keyHasBeenSeen<span class="token punctuation">;</span>
</code></pre></div><p>要理解这个代表的不仅仅是一个单独的布尔类型变量，而是一个分布式的共享键值存储。</p> <h4 id="清理状态"><a href="#清理状态" aria-hidden="true" class="header-anchor">#</a> 清理状态</h4> <p>在键无限增长的应用中，清除再也不会使用的状态是很必要的：</p> <div class="language-java extra-class"><pre class="language-java"><code>keyHasBeenSeen<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>也可以选择使用 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/dev/datastream/fault-tolerance/state/#state-time-to-live-ttl" target="_blank" rel="noopener noreferrer">状态的过期时间（TTL）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，为状态描述符配置你想要旧状态自动被清除的时间。</p> <h3 id="connected-streams"><a href="#connected-streams" aria-hidden="true" class="header-anchor">#</a> Connected Streams</h3> <p>当需要更灵活地调整转换的某些功能，可以使用<code>connected streams</code> ，一个单独的算子有两个输入流。</p> <p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/connected-streams.svg" alt="connected streams"></p> <p>connected stream 也可以被用来实现流的关联。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">StreamExecutionEnvironment</span> env <span class="token operator">=</span> <span class="token class-name">StreamExecutionEnvironment</span><span class="token punctuation">.</span><span class="token function">getExecutionEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">DataStream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> control <span class="token operator">=</span> env
        <span class="token punctuation">.</span><span class="token function">fromElements</span><span class="token punctuation">(</span><span class="token string">&quot;DROP&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;IGNORE&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">keyBy</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">DataStream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> streamOfWords <span class="token operator">=</span> env
        <span class="token punctuation">.</span><span class="token function">fromElements</span><span class="token punctuation">(</span><span class="token string">&quot;Apache&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;DROP&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Flink&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;IGNORE&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">keyBy</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    control
        <span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>streamOfWords<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ControlFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    env<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>两个流只有键一致的时候才能连接。 <code>keyBy</code> 的作用是将流数据分区，当 keyed stream 被连接时，他们必须按相同的方式分区。这样保证了两个流中所有键相同的事件发到同一个实例上。这样也使按键关联两个流成为可能。</p> <p>在这个例子中，两个流都是 <code>DataStream&lt;String&gt;</code> 类型的，并且都将字符串作为键。正如你将在下面看到的，<code>RichCoFlatMapFunction</code> 在状态中存了一个布尔类型的变量，这个变量被两个流共享。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ControlFunction</span> <span class="token keyword">extends</span> <span class="token class-name">RichCoFlatMapFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">ValueState</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> blocked<span class="token punctuation">;</span>
      
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token keyword">open</span><span class="token punctuation">(</span><span class="token class-name">Configuration</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        blocked <span class="token operator">=</span> <span class="token function">getRuntimeContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ValueStateDescriptor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;blocked&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
      
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flatMap1</span><span class="token punctuation">(</span><span class="token class-name">String</span> control_value<span class="token punctuation">,</span> <span class="token class-name">Collector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        blocked<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
      
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flatMap2</span><span class="token punctuation">(</span><span class="token class-name">String</span> data_value<span class="token punctuation">,</span> <span class="token class-name">Collector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>blocked<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            out<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>data_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>flatMap1</code> 和 <code>flatMap2</code> 的调用顺序是没法控制的，这两个输入流是相互竞争的关系。</p> <h2 id="事件驱动应用"><a href="#事件驱动应用" aria-hidden="true" class="header-anchor">#</a> 事件驱动应用</h2> <h2 id="容错处理"><a href="#容错处理" aria-hidden="true" class="header-anchor">#</a> 容错处理</h2></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">5/24/2021, 5:57:04 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/better-call-me-pumpkin/assets/js/app.99d21adc.js" defer></script><script src="/better-call-me-pumpkin/assets/js/16.c4f0918a.js" defer></script>
  </body>
</html>
